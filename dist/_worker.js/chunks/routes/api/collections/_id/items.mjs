import{d as i,e,g as t,h as a,f as d}from"../../../../_/nitro.mjs";import"node:async_hooks";const r=i(async i=>{const{user:r}=await e(i),n=t(i,"id"),s=a();if("GET"===i.method){const i=await s.prepare("SELECT id, created_at FROM items WHERE collection_id = ? ORDER BY created_at DESC").bind(n).all(),e=await s.prepare("\n      SELECT iv.item_id, iv.field_id, iv.value \n      FROM item_values iv\n      JOIN items i ON i.id = iv.item_id\n      WHERE i.collection_id = ?\n    ").bind(n).all(),t=new Map;return i.results.forEach(i=>{t.set(i.id,{id:i.id,created_at:i.created_at})}),e.results.forEach(i=>{const e=t.get(i.item_id);e&&(e[i.field_id]=JSON.parse(i.value))}),Array.from(t.values())}if("POST"===i.method){const e=await d(i),t=e.id||crypto.randomUUID();if(await s.prepare("\n      INSERT INTO items (id, collection_id)\n      VALUES (?, ?)\n      ON CONFLICT(id) DO UPDATE SET id = id -- Just to trigger upsert logic if needed\n    ").bind(t,n).run(),e.values&&"object"==typeof e.values)for(const[i,a]of Object.entries(e.values))await s.prepare("\n          INSERT INTO item_values (id, item_id, field_id, value)\n          VALUES (?, ?, ?, ?)\n          ON CONFLICT(item_id, field_id) DO UPDATE SET value = EXCLUDED.value\n        ").bind(crypto.randomUUID(),t,i,JSON.stringify(a)).run();return{id:t}}});export{r as default};
//# sourceMappingURL=items.mjs.map
