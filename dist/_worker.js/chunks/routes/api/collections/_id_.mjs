import{d as i,e,g as s,h as r,b as o,f as t}from"../../../_/nitro.mjs";import"node:async_hooks";const d=i(async i=>{const{user:d}=await e(i),n=s(i,"id"),a=r(),verifyOwnership=async()=>{const i=await a.prepare("SELECT user_id FROM collections WHERE id = ?").bind(n).first();if(!i||i.user_id!==d.id)throw o({statusCode:403,message:"Forbidden"})};if("GET"===i.method){const i=await a.prepare("SELECT * FROM collections WHERE id = ?").bind(n).first();if(!i)throw o({statusCode:404,message:"Not found"});if(i.user_id!==d.id&&"private"===i.visibility){if(!await a.prepare("SELECT id FROM collection_shares WHERE collection_id = ? AND (user_id = ? OR email = ?)").bind(n,d.id,d.email).first())throw o({statusCode:403,message:"Forbidden"})}const e=await a.prepare("SELECT * FROM fields WHERE collection_id = ? ORDER BY folder_order ASC").bind(n).all();return{...i,fields:e.results}}if("PATCH"===i.method){await verifyOwnership();const e=await t(i);if(await a.prepare("UPDATE collections SET name = ?, description = ?, visibility = ? WHERE id = ?").bind(e.name,e.description,e.visibility,n).run(),e.fields&&Array.isArray(e.fields))for(const i of e.fields){const e=i.id||crypto.randomUUID();await a.prepare("\n          INSERT INTO fields (id, collection_id, name, type, options, folder_order, visible, required, is_dynamic)\n          VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)\n          ON CONFLICT(id) DO UPDATE SET\n            name = EXCLUDED.name,\n            type = EXCLUDED.type,\n            options = EXCLUDED.options,\n            folder_order = EXCLUDED.folder_order,\n            visible = EXCLUDED.visible,\n            required = EXCLUDED.required,\n            is_dynamic = EXCLUDED.is_dynamic\n        ").bind(e,n,i.name,i.type,JSON.stringify(i.options||[]),i.folder_order||0,i.visible?1:0,i.required?1:0,i.is_dynamic?1:0).run()}return{success:!0}}if("DELETE"===i.method)return await verifyOwnership(),await a.prepare("DELETE FROM collections WHERE id = ?").bind(n).run(),{success:!0}});export{d as default};
//# sourceMappingURL=_id_.mjs.map
